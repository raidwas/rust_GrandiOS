\input{preamble}
\begin{document}
\HEADER{3}{Betriebssysteme}{WiSe 2017}{Sebastian Börner, Christian Hofmann, Simon Auch}{7 Dezember 2017, 10 Uhr}
\begin{description}
\AUFGABE{Nachrichten unterschiedlicher Länge}{5 Punkte}

Im Allgemeinen sind an Kommunikationsobjekten Nachrichten unterschiedlicher Länge zugelassen.
    \begin{itemize}
      \item Welche Auswirkungen hat dies auf die Daten des Kommunikationsobjekts? Bei welchen Varianten der Nachrichtenübergabe hat dies weitere Auswirkungen, und bei welchen hat dies sonst keine weiteren Auswirkungen?
      \item Welche Probleme können aus der Sicht der Kommunikationspartner auftreten, wenn Nachrichten unterschiedlicher Länge zugelassen sind? Schlagen Sie geeignete Lösungen vor!
    \end{itemize}

\textbf{Lösung:}

\AUFGABE{Kontextwechsel und präemptives Multitasking}{15 Punkte}

In  dieser  Aufgabe  soll  Ihr  Betriebssystem  um  die  Fähigkeit  des  präemptiven  Multitaskings erweitert  werden,  um  so  mehrere  Threads  quasi-parallel  ausführen  zu  können.  Der  System-Timer dient  dabei  als  Zeitgeber  und  gibt  das  Intervall  vor,  in  dem  der  Kern  den  gerade ausgeführten Thread automatisch wechselt. 

\textbf{Lösung:}
Anleitung zum Erstellen eines mit qemu benutzbaren Kernels:
\begin{enumerate}
  \item Wechseln in den Ordner \texttt{GrandiOS}
  \item Zunächst wird mit dem Script \texttt{setup\_env.sh} die Toolchain von Rust vorbereitet. Unter Umständen sind Benutzereingaben erwartet, diese können einfach mit Enter bestätigt werden.
  \item Ausführen von \texttt{make run} zum Erstellen eines Kernels und starten von Qemu mit diesem.
\end{enumerate}
Das Vorbereiten der Toolchain mittels \texttt{setup\_env.sh} ist nur einmal notwendig.

Für den unwahrscheinlichen Fall, dass aus irgendeinem Grund das Bauen des Kernels fehlschlägt, ist unter {\texttt{GrandiOS/kernels/kernel\_04}} noch ein von uns gebauter Kernel vorhanden.

Eine kleine Übersicht, wo die für diese Aufgabe relevanten Codesegmente zu finden sind:
\begin{itemize}
	\item \texttt{GrandiOS/src/utils/scheduler.rs} Implementation der Thread-Verwaltung. Unsere Zeitscheibenlänge beträgt standardmäßig 2 Sekunden, es sei denn ein Interrupt verkürzt diese. Insbesondere werden jedoch auch bei Benutzung eines Sleep-SWI die Zeitscheibe so eingestellt, dass der nächste Thread pünktlich gestartet werden kann. Falls es mehrere Threads der gleichen Priorität gibt, ergibt sich durch die Verwendung der Priority-Queue automatisch ein Round-Robin-Scheduling. Die maximale/minimale Zeitscheibenlänge kann hierbei zu Beginn/am Ende der Switch-Funktion eingestellt werden (in Ticks, wobei ein Tick als 1/1024 Sekunden eingestellt ist). Der Fall, dass es keinen Thread zum Ausführen gibt, kann nicht eintreten, da wir immer einen Idle-Thread haben, welcher immer ausgeführt werden kann (und nicht beendet werden kann). Der Idle-Thread pausiert insbesondere auch die CPU (siehe ganz unten in der Datei). Ein Thread kann mittels des Exit-Syscalls beendet werden, dies entfernt ihn aus allen Warteschlangen aus dem Scheduler und gibt später vielleicht irgendwann mal benutzte Ressourcen frei.
	\item \texttt{GrandiOS/src/utils/exceptions/common\_code.rs} Beinhaltet den Trampolincode für unsere Interrupts (sowohl swi als auch irq). Hierbei werden alle relevanten Register auf dem Interrupt-Stack gesichert. Falls der Thread gewechselt werden soll müssen diese nur woanders gespeichert werden und im Stack überschrieben werden.
	\item \texttt{GrandiOS/src/utils/exceptions/irq.rs} Beinhaltet die Implementierung des Threads, den wir starten, als auch die Ausgabe des Ausrufezeichens. Der Thread benutzt leider kein Sleep-Aufruf, da er hierfür in der aktuellen implementation einen Allocator benutzen muss, was jedoch im Kontext des Kernels (zu dem diese Datei gehört) leider der gleiche Allocator wie vom Scheduler ist und daher nicht ohne Kernellock benutzt werden sollte. Deswegen machen wir stattdessen einfach busy-waiting.
\end{itemize}

\end{description}
\end{document}
