\input{preamble}
\begin{document}
\HEADER{3}{Betriebssysteme}{WiSe 2017}{Sebastian Börner, Christian Hofmann, Simon Auch}{7 Dezember 2017, 10 Uhr}
\begin{description}
\AUFGABE{Threads}{6 Punkte}

Grenzen Sie die folgenden Begriffe auf Grund der Vorlesung gegeneinander ab: 
    \begin{itemize}
      \item gegenseitiger Ausschluss 
      \item Signalisierung 
      \item Synchronisation 
      \item Koordination 
      \item Kommunikation 
      \item Kooperation 
    \end{itemize}
Gehen Sie bei Ihrer Diskussion insbesondere auf die Teilnehmer und ihre Beziehung 
zueinander ein. 

\textbf{Lösung:}\\

    \begin{description}
      \item[gegenseitiger Ausschluss]
        Gegenseitiger Ausschluss dient dazu sicherzustellen, dass nicht zwei oder mehr Prozesse/Threads zeitgleich auf eine bestimmte Ressource zugreifen.
      \item[Signalisierung ]
        Signalisierung wird benutzt um zum Beispiel bei gegenseitigen Ausschluss anderen Prozessen/Threads, die auf eine vom aktuellen Prozess/Thread beanspruchte Ressource warten, zu signalisieren, dass diese wieder zu Verfügung steht.
      \item[Synchronisation ]
        \todo[inline]{soll sich das hier nur auf threads beziehen, also Prozesssynchronisation?}
      \item[Koordination ]
        Bei Koordination wird entschieden, wer wann worauf zugreifen kann. Bei Threads mit geteilter Ressource können dabei u.A. mehrere Threads (Leser) für die Ressource so koodiniert werden, dass diese zeitgleich drauf zugreifen können, sofern kein Schreiber für die Ressource grade aktiv ist (also anders als beim gegenseitigen Ausschluss wo je nur einer zugelassen wird).
      \item[Kommunikation ]
      \item[Kooperation ]
    \end{description}

\AUFGABE{Interrupts - System Timer und serielle Schnittstelle}{15 Punkte}

Mit dem Abfangen von Ausnahmen ist unser „Betriebssystem“ noch kein wirkliches Betriebs-
system, sondern eher ein Bare-Metal-Programm mit ein wenig Programmier-Komfort. Um 
diesen Umstand auszuräumen, unterstützen wir in dieser Aufgabe auch Hardware-Interrupts. 
Hardware-Interrupts bieten später die einzige Möglichkeit für das Betriebssystem die Kontrolle 
über den Prozessor wiedererlangen zu können, wenn mal ein Prozess in einer Endlosschleife 
hängen sollte. Außerdem geben uns Hardware-Interrupts die Möglichkeit, zeitnah auf Hardware 
zu reagieren, auch wenn der Prozessor gerade eigentlich mit etwas anderem beschäftigt ist. 

Speziell in dieser Aufgabe stellen wir das Lesen (und optional das Schreiben) von der seriellen 
Schnittstelle (bei uns DBGU) von Polling auf Interrupt-getriebene Behandlung um. Interrupt-
getriebenes Lesen verringert die Chance, dass wir ein Zeichen verpassen, weil wir es nicht 
rechtzeitig abgeholt haben. (Interruptgetriebenes Schreiben würde zudem ein Fortsetzen der 
Programmausführung ermöglichen, ohne dass auf die Fertigstellung der Übertragung des 
vorherigen Zeichens gewartet werden muss.) 

Damit sichergestellt ist, dass uns ein Hardware-Interrupt ereilt (auch wenn der Benutzer keine 
Taste drückt), setzen wir außerdem proaktiv den System Timer (ST) ein, um so periodisch 
Interrupts zu erzeugen und unserem Betriebssystem eine garantierte Eingriffsmöglichkeit zu 
geben. 
  

\pagebreak
\textbf{Lösung:}
    \todo[inline]{folgendes ist copy-paste (von zettel2)}
Anleitung zum erstellen eines mit qemu benutzbaren Kernels:
\begin{enumerate}
	\item Wechseln in den Ordner \texttt{GrandiOS}
        \item Einen von beiden Optionen ausführen:
          \begin{itemize}
            \item Ausführen von \texttt{make}. Falls schon eine Rust-Umgebung vorhanden ist, stattdessen \texttt{make build}.
            \item \begin{enumerate}
              \item Zunächst wird mit dem Script \texttt{setup\_env.sh} die Toolchain von Rust vorbereitet. Unter Umständen sind Benutzereingaben erwartet, diese können einfach mit Enter bestätigt werden.
              \item Durch starten von \texttt{kernel\_build.sh} kann nun der Kernel \texttt{kernel} erzeugt werden.
              \item Starten von qemu mit dem Kernel: \texttt{qemu-bsprak -piotelnet -kernel kernel}
              \item Starten einer telnet Verbindung zu qemu: \texttt{telnet localhost 44444}
            \end{enumerate}
          \end{itemize}
\end{enumerate}
Das vorbereiten der Toolchain mittels \texttt{setup\_env.sh} ist nur einmal notwendig.

Für den unwahrscheinlichen Fall, dass aus irgend einem Grund das bauen des Kernels fehlschlägt, ist unter {\texttt{GrandiOS/kernels/kernel\_02}} noch ein von uns gebauter Kernel vorhanden.

Für diese Aufgabe kann der Parameter \texttt{-piotelnet} in Schritt 4 sowie das Starten von telnet in Schritt 5 ausgelassen werden.

Eine kleine Übersicht wo die für diese Aufgabe relevanten Codesegmente zu finden sind:
\begin{itemize}
	\item Remap Befehl: \texttt{GrandiOS/src/lib.rs::init}
	\item Stack pointer konfigurieren: \texttt{GrandiOS/src/lib.rs::init}
	\item Aktivieren der IRQ und FIQ im Prozessor: \texttt{Grandios/src/lib.rs::init}
	\item Zugriff auf die IVT sowie den AIC: \texttt{GrandiOS/src/driver/interrupts.rs}
	\item Zum registrieren der einzelnen interrupt/exception Handler können nun die folgenden Befehle benutzt werden (der Code ist in src/commands/test.rs):
	\begin{itemize}
		\item \texttt{test interrupts\_undefined\_instruction} hinterlegt einen Handler für undefined instruction Ausnahmen
		\item \texttt{test interrupts\_software\_interrupt} hinterlegt einen Handler für software interrupt Ausnahmen
		\item \texttt{test interrupts\_prefetch\_abort} hinterlegt einen Handler für prefetch abort Ausnahmen
		\item \texttt{test interrupts\_data\_abort} hinterlegt einen Handler für data abort Ausnahmen
		\item \texttt{test interrupts\_aic} hinterlegt einen Handler für die IRQ Leitung und konfiguriert den AIC sowie die DebugUnit einen Interrupt für das empfangen eines Zeichens zu erzeugen. Diese Funktion geht in eine Endlosschleife, da durch den Interrupthandler zurzeit die Tastendrücke abgefangen werden und die \texttt{pfush} damit unbrauchbar wird.
	\end{itemize}
	\item Zum Betrachten was in die IVT geschrieben wurde, kann der Befehl \texttt{edit 0x0 0x40} genutzt werden. Wie der name nahelegt können hiermit auch Daten geschrieben werden, verlassen geht mit der Tastenkombination \texttt{strg-D}
        \item Zum Auslösen der einzelnen interrupts/exceptions können die folgenden Befehle benutzt werden:
	\begin{itemize}
		\item \texttt{test undefined\_instruction}
		\item \texttt{test software\_interrupt}
		\item \texttt{test prefetch\_abort} (noch nicht funktionsfähig da nur mit MMU möglich)
		\item \texttt{test data\_abort}
	\end{itemize}
\end{itemize}

\end{description}
\end{document}
